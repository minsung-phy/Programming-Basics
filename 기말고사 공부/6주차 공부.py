# 실습 6.1 논리 연산자로 흐름 제어
def bin_search_OX(ss, x):
    while ss != []:
        mid = len(ss) // 2
        if x == ss[mid]:
            return True
        elif x < ss[mid]:
            ss = ss[:mid]
        else:
            ss = ss[mid+1:]
    return False

def bin_search_OX(ss, x):
    mid = len(ss) // 2
    return ss != [] and (x == ss[mid] or x < ss[mid] and bin_search_OX(ss[:mid], x) or bin_search_OX(ss[mid+1:], x))

# 텍스트 파일 처리

# 파일 열기와 닫기:
# 파일을 대상으로 읽거나 쓰려면 먼저 파일을 용도에 맞추어 열어야 한다. 파일은 open 함수로 연다. 예를 들어 프로그램 파일과 같은 폴더에 위치한 input.txt 파일을 일기용으로 열고 싶으면 다음과 같이 쓴다.
# t = open("input.txt", "r")
# 여기서 open 함수 호출의 첫째 인수는 열고 싶은 파일 이름이다. 대상 파일이 다른 폴더에 잇는 경우에는 파일 경로도 함께 명시해야 한다.
# 둘째 인수인 "r"은 접근모드를 나타내는데, 파일을 읽을 (read) 용도로 열어달라는 요청이다. 
# open 함수로 열어준 input.txt 파일은 변수 t로 지정하였으므로, 이 변수를 통하여 연 파일에 접근 할 수 있다. 
# 파일을 읽기용으로 열면, 그 파일에 기록되어 있는 문자열을 맨 앞에서부터 순서대로 읽을 수 있고, 파일이 열려있는 동안 어디까지 읽었는지 기억해준다.
# 열었던 파일은 사용 후 반드시 다음과 같은 형식으로 닫아야 한다.
# t.close()
# 파일을 닫지 않으면 다른 프로그램의 접근 가능성을 열어두는 셈이 되므로, 보안을 위하여 한 번 연 파일은 사용후 반드시 닫도록 해야한다.
# 접근모드 / 의미
# "r" / 파일에서 읽음 (파일이 없으면 오류)
# "w" / 파일에 씀 (파일이 있으면 지우고 새로 씀, 없으면 새로 만듦)
# "x" / 새로 생성한 파일에 씀 (파일이 있으면 오류)
# "a" / 파일의 뒤에 이어서 씀 (파일이 없으면 새로 만듦)
# "r+" / 파일에서 읽고 씀 (파일이 없으면 오류)
# "w+" / 파일에 쓰고 읽음 (파일이 있으면 지우로 새로 씀, 없으면 새로 만듦)
# "a+" / 파일의 뒤에 이어서 쓰고 읽음 (파일이 없으면 새로 만듦)

# 텍스트 파일에서 문자열 읽기:
# input.txt에서 첫 n개의 문자를 읽어오려면, 그 파일을 읽을 용도로 열고 read(n) 메소드를 호출하면 된다. 
# 예를 들어 input.txt 파일에서 첫 문자 하나만 읽어오려면 다음과 같이 한다.
t = open("/Users/minsung/Documents/2학년 1학기/프로그래밍기초/기말고사 공부/input.txt", "r")
print(t.read(1))
# 이어서 9자를 더 읽어서 프린트하고 싶으면 계속해서 다음과 같이 한다.
print(t.read(9))
# 읽을 때 어디까지 읽었는지 항상 기억하기 때문에, 추후에 읽으면 기억해 둔 곳에서부터 읽는다. 
# 파일 끝에 도달하면 그 이후에 읽은 결과는 빈 문자열이 된다. 처음부터 다시 읽고 싶으면 다음과 같이 해당 파일을 닫고 다시 열어야 한다.
t.close()
t = open("/Users/minsung/Documents/2학년 1학기/프로그래밍기초/기말고사 공부/input.txt", "r")
# 다음과 같이 읽을 문자의 개수를 명시하지 않으면 파일에서 남은 문자열 전체를 끝까지 다 읽어버린다.
print(t.read())
# 바로 전에 파일 t를 다시 열었기 때문에, 파일을 처음부터 끝까지 모두 읽어서 실행창에 프린트했다.
t.close()

# 파일에서 현재 읽고 있는 줄에서만 n개의 문자를 읽어오려면 readline(n) 메소드를 쓴다.
t = open("/Users/minsung/Documents/2학년 1학기/프로그래밍기초/기말고사 공부/input.txt", "r")
print(t.readline(1))
print(t.readline(9))
t.close()
# 이 사례만 보면 read(n)과 별 차이가 없어 보인다. 그러나 차이가 있다. 
# read(n)은 파일 전체에서 문자 n개를 읽어오는 반면, readline(n)은 현재 줄에서만 문자 n개를 읽어오고 다음 줄로 절대 넘어가지 않는다.
# readline()은 파일을 한 줄 단위로 읽을 때 편리하게 사용할 수 있다. 예를 들어 input.txt 파일을 한 줄씩 읽어서 프린트하려면 다음과 같이 하면 된다.
t = open("/Users/minsung/Documents/2학년 1학기/프로그래밍기초/기말고사 공부/input.txt", "r")
print(t.readline())
print(t.readline())
print(t.readline())
t.close()

# 텍스트 파일에 문자열 쓰기:
# 텍스트 파일에 쓸 때도 쓰기 전에 해당 파일을 먼저 열어야 한다. output.txt 파일에 문자열을 쓰고 싶으면 다음과 같이 "w"모드로 파일을 열어야 한다.
t = open("/Users/minsung/Documents/2학년 1학기/프로그래밍기초/기말고사 공부/output.txt", "w")
# 그러면 내용이 비어있는 output.txt 파일이 새로 생겨나며 파일에 문자열을 써주기를 기다린다. 만약 같은 이름의 파일이 이미 있다면, 그 파일을 지우고 내용이 빈 새로운 파일로 대체한다.
# 기존 파일을 의도치 않게 지워버리는 사고를 방지하고 싶으면 "x"모드를 사용한다. 이 모드는 같은 이름의 파일이 있으면, 쓰는 대신 오류가 발생한다.

# 파일 t에 문자열을 쓰려면 write() 메소드를 다음과 같이 호출한다.
t.write("새 나라의 어린이는 일찍 일어납니다\n")
# 그런데 write() 메소드는 쓰는 문자열의 맨 끝에 줄바꿈 문자를 넣지 않는다. 따라서 줄을 바꾸고 싶으면 원하는 위치에 "\n"을 명시해야 한다.
t.write("잠꾸러기 없는 나라\n")
t.write("우리나라 좋은 나라\n")
t.close()
# 위에서 본 input.txt 파일과 똑같은 내용이 들어있는 output.txt를 위와 같이 만들 수 있다.

# 파일 메소드 요약:
# 메소드 / 실행의미
# close() / 파일을 닫는다. 일단 닫힌 파일은 다시 열기 전에는 읽거나 쓸 수 없다.
# read(n) / 파일의 현재 위치에서 문자 n개를 읽어서 문자열로 리턴한다.
# read() / 파일의 현재 위치에서 파일의 끝까지 모두 문자열로 리턴한다.
# readline(n) / 파일의 현재 위치에서 그 줄의 문자 n개를 읽어서 문자열로 리턴한다.
# readline() / 파일의 현재 위치에서 그 줄의 끝까지 모두 문자열로 리턴한다.
# readlines() / 파일의 현재 위치에서 한 줄씩 끝가지 읽어서 줄의 리스트로 리턴한다.
# write(s) / 문자열 s를 파일의 현재 위치에 쓴다.
# writelines(ss) / 문자열 리스트 ss에 있는 문자열을 모두 파일의 현재 위치에 쓴다.