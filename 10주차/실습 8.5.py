def radixsort(ds):
    if ds != []:
        length = len(ds[0])
        for i in range(length - 1, -1, -1):
            distributed = [[] for _ in range(10)]
            for d in ds:
                distributed[int(d[i])].append(d)
            ds = []
            for d in distributed:
                ds += d
        return ds
    else:
        return []

# Test code
print(radixsort([]))
print(radixsort(["239"]))
print(radixsort(["170",'045','075','090','002','024','802','066']))
print(radixsort(["239",'234','879','878','123','358','416','317','137','225']))
print(radixsort(["0505", "0515", "1225", "0915", "1111", "0101", "0318", "0301"]))
print(radixsort(["01000", "00100", "00001", "10000", "00010"]))

# 이 코드는 주어진 리스트 ds를 기수 정렬을 사용하여 정렬합니다.
# 기수 정렬은 각 값을 자리수별로 분해하여 정렬하는 방식입니다. 이때, 각 자리수를 비교해 가며 정렬하므로 안정 정렬에 속합니다.
# 이 코드에서는 먼저, 주어진 리스트 ds 중 가장 긴 원소의 자리수를 찾습니다. 그리고 이 자리수부터 가장 작은 자리수까지(여기서는 0) 반복문을 돌면서 각 자리수별로 정렬합니다.
# 각 자리수별로 정렬은 다음과 같이 이루어집니다.
# 0~9까지의 리스트 distributed를 만듭니다.
# ds에서 각 원소를 자리수(i)에 따라 분배합니다. 예를 들어, ds에 있는 원소 중 자리수 i가 3이면, distributed의 3번째 리스트에 해당 원소를 추가합니다. 이렇게 하면 distributed[0]에는 ds에서 0이 있는 원소들, distributed[1]에는 1이 있는 원소들 등이 들어갑니다.
# 분배된 원소들을 순서대로 다시 ds에 추가합니다.
# ds가 정렬된 결과를 가지고 다음 자리수(i-1)에 대한 정렬을 수행합니다.
# 각 자리수별로 위의 과정을 반복하면, 최종적으로 ds는 기수 정렬 알고리즘에 따라 정렬된 결과를 가지게 됩니다.